// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'home_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$HomeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() requestLoading,
    required TResult Function() noDataConnectionState,
    required TResult Function() noPosState,
    required TResult Function() noMerchantState,
    required TResult Function(List<PaymentRequest> requests) requestLoaded,
    required TResult Function(String error) requestsLoadingErrorState,
    required TResult Function(Object error, StackTrace st) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? requestLoading,
    TResult? Function()? noDataConnectionState,
    TResult? Function()? noPosState,
    TResult? Function()? noMerchantState,
    TResult? Function(List<PaymentRequest> requests)? requestLoaded,
    TResult? Function(String error)? requestsLoadingErrorState,
    TResult? Function(Object error, StackTrace st)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? requestLoading,
    TResult Function()? noDataConnectionState,
    TResult Function()? noPosState,
    TResult Function()? noMerchantState,
    TResult Function(List<PaymentRequest> requests)? requestLoaded,
    TResult Function(String error)? requestsLoadingErrorState,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RequestLoading value) requestLoading,
    required TResult Function(NoDataConnectionState value)
        noDataConnectionState,
    required TResult Function(NoPosState value) noPosState,
    required TResult Function(NoMerchantState value) noMerchantState,
    required TResult Function(RequestLoaded value) requestLoaded,
    required TResult Function(RequestsLoadingErrorState value)
        requestsLoadingErrorState,
    required TResult Function(HomeStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RequestLoading value)? requestLoading,
    TResult? Function(NoDataConnectionState value)? noDataConnectionState,
    TResult? Function(NoPosState value)? noPosState,
    TResult? Function(NoMerchantState value)? noMerchantState,
    TResult? Function(RequestLoaded value)? requestLoaded,
    TResult? Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult? Function(HomeStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RequestLoading value)? requestLoading,
    TResult Function(NoDataConnectionState value)? noDataConnectionState,
    TResult Function(NoPosState value)? noPosState,
    TResult Function(NoMerchantState value)? noMerchantState,
    TResult Function(RequestLoaded value)? requestLoaded,
    TResult Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult Function(HomeStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeStateCopyWith<$Res> {
  factory $HomeStateCopyWith(HomeState value, $Res Function(HomeState) then) =
      _$HomeStateCopyWithImpl<$Res, HomeState>;
}

/// @nodoc
class _$HomeStateCopyWithImpl<$Res, $Val extends HomeState>
    implements $HomeStateCopyWith<$Res> {
  _$HomeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$RequestLoadingImplCopyWith<$Res> {
  factory _$$RequestLoadingImplCopyWith(_$RequestLoadingImpl value,
          $Res Function(_$RequestLoadingImpl) then) =
      __$$RequestLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RequestLoadingImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$RequestLoadingImpl>
    implements _$$RequestLoadingImplCopyWith<$Res> {
  __$$RequestLoadingImplCopyWithImpl(
      _$RequestLoadingImpl _value, $Res Function(_$RequestLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RequestLoadingImpl implements RequestLoading {
  const _$RequestLoadingImpl();

  @override
  String toString() {
    return 'HomeState.requestLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RequestLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() requestLoading,
    required TResult Function() noDataConnectionState,
    required TResult Function() noPosState,
    required TResult Function() noMerchantState,
    required TResult Function(List<PaymentRequest> requests) requestLoaded,
    required TResult Function(String error) requestsLoadingErrorState,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return requestLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? requestLoading,
    TResult? Function()? noDataConnectionState,
    TResult? Function()? noPosState,
    TResult? Function()? noMerchantState,
    TResult? Function(List<PaymentRequest> requests)? requestLoaded,
    TResult? Function(String error)? requestsLoadingErrorState,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return requestLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? requestLoading,
    TResult Function()? noDataConnectionState,
    TResult Function()? noPosState,
    TResult Function()? noMerchantState,
    TResult Function(List<PaymentRequest> requests)? requestLoaded,
    TResult Function(String error)? requestsLoadingErrorState,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (requestLoading != null) {
      return requestLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RequestLoading value) requestLoading,
    required TResult Function(NoDataConnectionState value)
        noDataConnectionState,
    required TResult Function(NoPosState value) noPosState,
    required TResult Function(NoMerchantState value) noMerchantState,
    required TResult Function(RequestLoaded value) requestLoaded,
    required TResult Function(RequestsLoadingErrorState value)
        requestsLoadingErrorState,
    required TResult Function(HomeStateError value) error,
  }) {
    return requestLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RequestLoading value)? requestLoading,
    TResult? Function(NoDataConnectionState value)? noDataConnectionState,
    TResult? Function(NoPosState value)? noPosState,
    TResult? Function(NoMerchantState value)? noMerchantState,
    TResult? Function(RequestLoaded value)? requestLoaded,
    TResult? Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult? Function(HomeStateError value)? error,
  }) {
    return requestLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RequestLoading value)? requestLoading,
    TResult Function(NoDataConnectionState value)? noDataConnectionState,
    TResult Function(NoPosState value)? noPosState,
    TResult Function(NoMerchantState value)? noMerchantState,
    TResult Function(RequestLoaded value)? requestLoaded,
    TResult Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult Function(HomeStateError value)? error,
    required TResult orElse(),
  }) {
    if (requestLoading != null) {
      return requestLoading(this);
    }
    return orElse();
  }
}

abstract class RequestLoading implements HomeState {
  const factory RequestLoading() = _$RequestLoadingImpl;
}

/// @nodoc
abstract class _$$NoDataConnectionStateImplCopyWith<$Res> {
  factory _$$NoDataConnectionStateImplCopyWith(
          _$NoDataConnectionStateImpl value,
          $Res Function(_$NoDataConnectionStateImpl) then) =
      __$$NoDataConnectionStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoDataConnectionStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$NoDataConnectionStateImpl>
    implements _$$NoDataConnectionStateImplCopyWith<$Res> {
  __$$NoDataConnectionStateImplCopyWithImpl(_$NoDataConnectionStateImpl _value,
      $Res Function(_$NoDataConnectionStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoDataConnectionStateImpl implements NoDataConnectionState {
  const _$NoDataConnectionStateImpl();

  @override
  String toString() {
    return 'HomeState.noDataConnectionState()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NoDataConnectionStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() requestLoading,
    required TResult Function() noDataConnectionState,
    required TResult Function() noPosState,
    required TResult Function() noMerchantState,
    required TResult Function(List<PaymentRequest> requests) requestLoaded,
    required TResult Function(String error) requestsLoadingErrorState,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return noDataConnectionState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? requestLoading,
    TResult? Function()? noDataConnectionState,
    TResult? Function()? noPosState,
    TResult? Function()? noMerchantState,
    TResult? Function(List<PaymentRequest> requests)? requestLoaded,
    TResult? Function(String error)? requestsLoadingErrorState,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return noDataConnectionState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? requestLoading,
    TResult Function()? noDataConnectionState,
    TResult Function()? noPosState,
    TResult Function()? noMerchantState,
    TResult Function(List<PaymentRequest> requests)? requestLoaded,
    TResult Function(String error)? requestsLoadingErrorState,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (noDataConnectionState != null) {
      return noDataConnectionState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RequestLoading value) requestLoading,
    required TResult Function(NoDataConnectionState value)
        noDataConnectionState,
    required TResult Function(NoPosState value) noPosState,
    required TResult Function(NoMerchantState value) noMerchantState,
    required TResult Function(RequestLoaded value) requestLoaded,
    required TResult Function(RequestsLoadingErrorState value)
        requestsLoadingErrorState,
    required TResult Function(HomeStateError value) error,
  }) {
    return noDataConnectionState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RequestLoading value)? requestLoading,
    TResult? Function(NoDataConnectionState value)? noDataConnectionState,
    TResult? Function(NoPosState value)? noPosState,
    TResult? Function(NoMerchantState value)? noMerchantState,
    TResult? Function(RequestLoaded value)? requestLoaded,
    TResult? Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult? Function(HomeStateError value)? error,
  }) {
    return noDataConnectionState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RequestLoading value)? requestLoading,
    TResult Function(NoDataConnectionState value)? noDataConnectionState,
    TResult Function(NoPosState value)? noPosState,
    TResult Function(NoMerchantState value)? noMerchantState,
    TResult Function(RequestLoaded value)? requestLoaded,
    TResult Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult Function(HomeStateError value)? error,
    required TResult orElse(),
  }) {
    if (noDataConnectionState != null) {
      return noDataConnectionState(this);
    }
    return orElse();
  }
}

abstract class NoDataConnectionState implements HomeState {
  const factory NoDataConnectionState() = _$NoDataConnectionStateImpl;
}

/// @nodoc
abstract class _$$NoPosStateImplCopyWith<$Res> {
  factory _$$NoPosStateImplCopyWith(
          _$NoPosStateImpl value, $Res Function(_$NoPosStateImpl) then) =
      __$$NoPosStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoPosStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$NoPosStateImpl>
    implements _$$NoPosStateImplCopyWith<$Res> {
  __$$NoPosStateImplCopyWithImpl(
      _$NoPosStateImpl _value, $Res Function(_$NoPosStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoPosStateImpl implements NoPosState {
  const _$NoPosStateImpl();

  @override
  String toString() {
    return 'HomeState.noPosState()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoPosStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() requestLoading,
    required TResult Function() noDataConnectionState,
    required TResult Function() noPosState,
    required TResult Function() noMerchantState,
    required TResult Function(List<PaymentRequest> requests) requestLoaded,
    required TResult Function(String error) requestsLoadingErrorState,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return noPosState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? requestLoading,
    TResult? Function()? noDataConnectionState,
    TResult? Function()? noPosState,
    TResult? Function()? noMerchantState,
    TResult? Function(List<PaymentRequest> requests)? requestLoaded,
    TResult? Function(String error)? requestsLoadingErrorState,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return noPosState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? requestLoading,
    TResult Function()? noDataConnectionState,
    TResult Function()? noPosState,
    TResult Function()? noMerchantState,
    TResult Function(List<PaymentRequest> requests)? requestLoaded,
    TResult Function(String error)? requestsLoadingErrorState,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (noPosState != null) {
      return noPosState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RequestLoading value) requestLoading,
    required TResult Function(NoDataConnectionState value)
        noDataConnectionState,
    required TResult Function(NoPosState value) noPosState,
    required TResult Function(NoMerchantState value) noMerchantState,
    required TResult Function(RequestLoaded value) requestLoaded,
    required TResult Function(RequestsLoadingErrorState value)
        requestsLoadingErrorState,
    required TResult Function(HomeStateError value) error,
  }) {
    return noPosState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RequestLoading value)? requestLoading,
    TResult? Function(NoDataConnectionState value)? noDataConnectionState,
    TResult? Function(NoPosState value)? noPosState,
    TResult? Function(NoMerchantState value)? noMerchantState,
    TResult? Function(RequestLoaded value)? requestLoaded,
    TResult? Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult? Function(HomeStateError value)? error,
  }) {
    return noPosState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RequestLoading value)? requestLoading,
    TResult Function(NoDataConnectionState value)? noDataConnectionState,
    TResult Function(NoPosState value)? noPosState,
    TResult Function(NoMerchantState value)? noMerchantState,
    TResult Function(RequestLoaded value)? requestLoaded,
    TResult Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult Function(HomeStateError value)? error,
    required TResult orElse(),
  }) {
    if (noPosState != null) {
      return noPosState(this);
    }
    return orElse();
  }
}

abstract class NoPosState implements HomeState {
  const factory NoPosState() = _$NoPosStateImpl;
}

/// @nodoc
abstract class _$$NoMerchantStateImplCopyWith<$Res> {
  factory _$$NoMerchantStateImplCopyWith(_$NoMerchantStateImpl value,
          $Res Function(_$NoMerchantStateImpl) then) =
      __$$NoMerchantStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoMerchantStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$NoMerchantStateImpl>
    implements _$$NoMerchantStateImplCopyWith<$Res> {
  __$$NoMerchantStateImplCopyWithImpl(
      _$NoMerchantStateImpl _value, $Res Function(_$NoMerchantStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoMerchantStateImpl implements NoMerchantState {
  const _$NoMerchantStateImpl();

  @override
  String toString() {
    return 'HomeState.noMerchantState()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoMerchantStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() requestLoading,
    required TResult Function() noDataConnectionState,
    required TResult Function() noPosState,
    required TResult Function() noMerchantState,
    required TResult Function(List<PaymentRequest> requests) requestLoaded,
    required TResult Function(String error) requestsLoadingErrorState,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return noMerchantState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? requestLoading,
    TResult? Function()? noDataConnectionState,
    TResult? Function()? noPosState,
    TResult? Function()? noMerchantState,
    TResult? Function(List<PaymentRequest> requests)? requestLoaded,
    TResult? Function(String error)? requestsLoadingErrorState,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return noMerchantState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? requestLoading,
    TResult Function()? noDataConnectionState,
    TResult Function()? noPosState,
    TResult Function()? noMerchantState,
    TResult Function(List<PaymentRequest> requests)? requestLoaded,
    TResult Function(String error)? requestsLoadingErrorState,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (noMerchantState != null) {
      return noMerchantState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RequestLoading value) requestLoading,
    required TResult Function(NoDataConnectionState value)
        noDataConnectionState,
    required TResult Function(NoPosState value) noPosState,
    required TResult Function(NoMerchantState value) noMerchantState,
    required TResult Function(RequestLoaded value) requestLoaded,
    required TResult Function(RequestsLoadingErrorState value)
        requestsLoadingErrorState,
    required TResult Function(HomeStateError value) error,
  }) {
    return noMerchantState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RequestLoading value)? requestLoading,
    TResult? Function(NoDataConnectionState value)? noDataConnectionState,
    TResult? Function(NoPosState value)? noPosState,
    TResult? Function(NoMerchantState value)? noMerchantState,
    TResult? Function(RequestLoaded value)? requestLoaded,
    TResult? Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult? Function(HomeStateError value)? error,
  }) {
    return noMerchantState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RequestLoading value)? requestLoading,
    TResult Function(NoDataConnectionState value)? noDataConnectionState,
    TResult Function(NoPosState value)? noPosState,
    TResult Function(NoMerchantState value)? noMerchantState,
    TResult Function(RequestLoaded value)? requestLoaded,
    TResult Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult Function(HomeStateError value)? error,
    required TResult orElse(),
  }) {
    if (noMerchantState != null) {
      return noMerchantState(this);
    }
    return orElse();
  }
}

abstract class NoMerchantState implements HomeState {
  const factory NoMerchantState() = _$NoMerchantStateImpl;
}

/// @nodoc
abstract class _$$RequestLoadedImplCopyWith<$Res> {
  factory _$$RequestLoadedImplCopyWith(
          _$RequestLoadedImpl value, $Res Function(_$RequestLoadedImpl) then) =
      __$$RequestLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<PaymentRequest> requests});
}

/// @nodoc
class __$$RequestLoadedImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$RequestLoadedImpl>
    implements _$$RequestLoadedImplCopyWith<$Res> {
  __$$RequestLoadedImplCopyWithImpl(
      _$RequestLoadedImpl _value, $Res Function(_$RequestLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? requests = null,
  }) {
    return _then(_$RequestLoadedImpl(
      requests: null == requests
          ? _value._requests
          : requests // ignore: cast_nullable_to_non_nullable
              as List<PaymentRequest>,
    ));
  }
}

/// @nodoc

class _$RequestLoadedImpl implements RequestLoaded {
  const _$RequestLoadedImpl({required final List<PaymentRequest> requests})
      : _requests = requests;

  final List<PaymentRequest> _requests;
  @override
  List<PaymentRequest> get requests {
    if (_requests is EqualUnmodifiableListView) return _requests;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_requests);
  }

  @override
  String toString() {
    return 'HomeState.requestLoaded(requests: $requests)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RequestLoadedImpl &&
            const DeepCollectionEquality().equals(other._requests, _requests));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_requests));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RequestLoadedImplCopyWith<_$RequestLoadedImpl> get copyWith =>
      __$$RequestLoadedImplCopyWithImpl<_$RequestLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() requestLoading,
    required TResult Function() noDataConnectionState,
    required TResult Function() noPosState,
    required TResult Function() noMerchantState,
    required TResult Function(List<PaymentRequest> requests) requestLoaded,
    required TResult Function(String error) requestsLoadingErrorState,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return requestLoaded(requests);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? requestLoading,
    TResult? Function()? noDataConnectionState,
    TResult? Function()? noPosState,
    TResult? Function()? noMerchantState,
    TResult? Function(List<PaymentRequest> requests)? requestLoaded,
    TResult? Function(String error)? requestsLoadingErrorState,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return requestLoaded?.call(requests);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? requestLoading,
    TResult Function()? noDataConnectionState,
    TResult Function()? noPosState,
    TResult Function()? noMerchantState,
    TResult Function(List<PaymentRequest> requests)? requestLoaded,
    TResult Function(String error)? requestsLoadingErrorState,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (requestLoaded != null) {
      return requestLoaded(requests);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RequestLoading value) requestLoading,
    required TResult Function(NoDataConnectionState value)
        noDataConnectionState,
    required TResult Function(NoPosState value) noPosState,
    required TResult Function(NoMerchantState value) noMerchantState,
    required TResult Function(RequestLoaded value) requestLoaded,
    required TResult Function(RequestsLoadingErrorState value)
        requestsLoadingErrorState,
    required TResult Function(HomeStateError value) error,
  }) {
    return requestLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RequestLoading value)? requestLoading,
    TResult? Function(NoDataConnectionState value)? noDataConnectionState,
    TResult? Function(NoPosState value)? noPosState,
    TResult? Function(NoMerchantState value)? noMerchantState,
    TResult? Function(RequestLoaded value)? requestLoaded,
    TResult? Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult? Function(HomeStateError value)? error,
  }) {
    return requestLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RequestLoading value)? requestLoading,
    TResult Function(NoDataConnectionState value)? noDataConnectionState,
    TResult Function(NoPosState value)? noPosState,
    TResult Function(NoMerchantState value)? noMerchantState,
    TResult Function(RequestLoaded value)? requestLoaded,
    TResult Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult Function(HomeStateError value)? error,
    required TResult orElse(),
  }) {
    if (requestLoaded != null) {
      return requestLoaded(this);
    }
    return orElse();
  }
}

abstract class RequestLoaded implements HomeState {
  const factory RequestLoaded({required final List<PaymentRequest> requests}) =
      _$RequestLoadedImpl;

  List<PaymentRequest> get requests;
  @JsonKey(ignore: true)
  _$$RequestLoadedImplCopyWith<_$RequestLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RequestsLoadingErrorStateImplCopyWith<$Res> {
  factory _$$RequestsLoadingErrorStateImplCopyWith(
          _$RequestsLoadingErrorStateImpl value,
          $Res Function(_$RequestsLoadingErrorStateImpl) then) =
      __$$RequestsLoadingErrorStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$RequestsLoadingErrorStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$RequestsLoadingErrorStateImpl>
    implements _$$RequestsLoadingErrorStateImplCopyWith<$Res> {
  __$$RequestsLoadingErrorStateImplCopyWithImpl(
      _$RequestsLoadingErrorStateImpl _value,
      $Res Function(_$RequestsLoadingErrorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$RequestsLoadingErrorStateImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$RequestsLoadingErrorStateImpl implements RequestsLoadingErrorState {
  const _$RequestsLoadingErrorStateImpl(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'HomeState.requestsLoadingErrorState(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RequestsLoadingErrorStateImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RequestsLoadingErrorStateImplCopyWith<_$RequestsLoadingErrorStateImpl>
      get copyWith => __$$RequestsLoadingErrorStateImplCopyWithImpl<
          _$RequestsLoadingErrorStateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() requestLoading,
    required TResult Function() noDataConnectionState,
    required TResult Function() noPosState,
    required TResult Function() noMerchantState,
    required TResult Function(List<PaymentRequest> requests) requestLoaded,
    required TResult Function(String error) requestsLoadingErrorState,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return requestsLoadingErrorState(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? requestLoading,
    TResult? Function()? noDataConnectionState,
    TResult? Function()? noPosState,
    TResult? Function()? noMerchantState,
    TResult? Function(List<PaymentRequest> requests)? requestLoaded,
    TResult? Function(String error)? requestsLoadingErrorState,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return requestsLoadingErrorState?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? requestLoading,
    TResult Function()? noDataConnectionState,
    TResult Function()? noPosState,
    TResult Function()? noMerchantState,
    TResult Function(List<PaymentRequest> requests)? requestLoaded,
    TResult Function(String error)? requestsLoadingErrorState,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (requestsLoadingErrorState != null) {
      return requestsLoadingErrorState(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RequestLoading value) requestLoading,
    required TResult Function(NoDataConnectionState value)
        noDataConnectionState,
    required TResult Function(NoPosState value) noPosState,
    required TResult Function(NoMerchantState value) noMerchantState,
    required TResult Function(RequestLoaded value) requestLoaded,
    required TResult Function(RequestsLoadingErrorState value)
        requestsLoadingErrorState,
    required TResult Function(HomeStateError value) error,
  }) {
    return requestsLoadingErrorState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RequestLoading value)? requestLoading,
    TResult? Function(NoDataConnectionState value)? noDataConnectionState,
    TResult? Function(NoPosState value)? noPosState,
    TResult? Function(NoMerchantState value)? noMerchantState,
    TResult? Function(RequestLoaded value)? requestLoaded,
    TResult? Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult? Function(HomeStateError value)? error,
  }) {
    return requestsLoadingErrorState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RequestLoading value)? requestLoading,
    TResult Function(NoDataConnectionState value)? noDataConnectionState,
    TResult Function(NoPosState value)? noPosState,
    TResult Function(NoMerchantState value)? noMerchantState,
    TResult Function(RequestLoaded value)? requestLoaded,
    TResult Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult Function(HomeStateError value)? error,
    required TResult orElse(),
  }) {
    if (requestsLoadingErrorState != null) {
      return requestsLoadingErrorState(this);
    }
    return orElse();
  }
}

abstract class RequestsLoadingErrorState implements HomeState {
  const factory RequestsLoadingErrorState(final String error) =
      _$RequestsLoadingErrorStateImpl;

  String get error;
  @JsonKey(ignore: true)
  _$$RequestsLoadingErrorStateImplCopyWith<_$RequestsLoadingErrorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$HomeStateErrorImplCopyWith<$Res> {
  factory _$$HomeStateErrorImplCopyWith(_$HomeStateErrorImpl value,
          $Res Function(_$HomeStateErrorImpl) then) =
      __$$HomeStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object error, StackTrace st});
}

/// @nodoc
class __$$HomeStateErrorImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$HomeStateErrorImpl>
    implements _$$HomeStateErrorImplCopyWith<$Res> {
  __$$HomeStateErrorImplCopyWithImpl(
      _$HomeStateErrorImpl _value, $Res Function(_$HomeStateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
    Object? st = null,
  }) {
    return _then(_$HomeStateErrorImpl(
      null == error ? _value.error : error,
      null == st
          ? _value.st
          : st // ignore: cast_nullable_to_non_nullable
              as StackTrace,
    ));
  }
}

/// @nodoc

class _$HomeStateErrorImpl implements HomeStateError {
  const _$HomeStateErrorImpl(this.error, this.st);

  @override
  final Object error;
  @override
  final StackTrace st;

  @override
  String toString() {
    return 'HomeState.error(error: $error, st: $st)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomeStateErrorImpl &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.st, st) || other.st == st));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error), st);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HomeStateErrorImplCopyWith<_$HomeStateErrorImpl> get copyWith =>
      __$$HomeStateErrorImplCopyWithImpl<_$HomeStateErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() requestLoading,
    required TResult Function() noDataConnectionState,
    required TResult Function() noPosState,
    required TResult Function() noMerchantState,
    required TResult Function(List<PaymentRequest> requests) requestLoaded,
    required TResult Function(String error) requestsLoadingErrorState,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return error(this.error, st);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? requestLoading,
    TResult? Function()? noDataConnectionState,
    TResult? Function()? noPosState,
    TResult? Function()? noMerchantState,
    TResult? Function(List<PaymentRequest> requests)? requestLoaded,
    TResult? Function(String error)? requestsLoadingErrorState,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return error?.call(this.error, st);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? requestLoading,
    TResult Function()? noDataConnectionState,
    TResult Function()? noPosState,
    TResult Function()? noMerchantState,
    TResult Function(List<PaymentRequest> requests)? requestLoaded,
    TResult Function(String error)? requestsLoadingErrorState,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, st);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RequestLoading value) requestLoading,
    required TResult Function(NoDataConnectionState value)
        noDataConnectionState,
    required TResult Function(NoPosState value) noPosState,
    required TResult Function(NoMerchantState value) noMerchantState,
    required TResult Function(RequestLoaded value) requestLoaded,
    required TResult Function(RequestsLoadingErrorState value)
        requestsLoadingErrorState,
    required TResult Function(HomeStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RequestLoading value)? requestLoading,
    TResult? Function(NoDataConnectionState value)? noDataConnectionState,
    TResult? Function(NoPosState value)? noPosState,
    TResult? Function(NoMerchantState value)? noMerchantState,
    TResult? Function(RequestLoaded value)? requestLoaded,
    TResult? Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult? Function(HomeStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RequestLoading value)? requestLoading,
    TResult Function(NoDataConnectionState value)? noDataConnectionState,
    TResult Function(NoPosState value)? noPosState,
    TResult Function(NoMerchantState value)? noMerchantState,
    TResult Function(RequestLoaded value)? requestLoaded,
    TResult Function(RequestsLoadingErrorState value)?
        requestsLoadingErrorState,
    TResult Function(HomeStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class HomeStateError implements HomeState {
  const factory HomeStateError(final Object error, final StackTrace st) =
      _$HomeStateErrorImpl;

  Object get error;
  StackTrace get st;
  @JsonKey(ignore: true)
  _$$HomeStateErrorImplCopyWith<_$HomeStateErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
